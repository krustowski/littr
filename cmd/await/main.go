package main

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/maxence-charriere/go-app/v9/pkg/app"
)

type MyApp struct {
	app.Compo
	Data string
}

// Pregenerated by ChatGPT.
func (m *MyApp) Render() app.UI {
	return app.Div().Body(
		app.H1().Text("HTTP Fetch Example in Go using WASM"),
		app.Button().Text("Fetch Data").OnClick(m.onFetchData),
		app.If(m.Data != "", app.P().Text(m.Data)),
	)
}

func (m *MyApp) onFetchData(ctx app.Context, e app.Event) {
	go func() {
		url := "http://localhost:8081/api/v1"

		fetch := app.Window().Get("fetch")

		promise := fetch.Invoke(url)

		promise.Then(func(response app.Value) {
			if response.Get("status").Int() != 200 {
				// Notify the UI's component.
				ctx.Dispatch(func(ctx app.Context) {
					m.Data = fmt.Sprintf("Unexpected HTTP status code: %d (%s).\n", response.Get("status").Int(), response.Get("statusText").String())
				})
				return
			}

			if response.Get("ok").Bool() {
				// [object Response]
				//fmt.Printf("%s\n", response.Call("toString").String())

				// {}
				//fmt.Printf("%s\n", app.Window().Get("JSON").Call("stringify", response).String())

				response.Call("json").Then(func(result app.Value) {
					// [object Object]
					//fmt.Printf("%s\n", result.Call("toString").String())

					// {"message": "lmao"}
					//fmt.Printf("%s\n", app.Window().Get("JSON").Call("stringify", result).String())
					rawJSON := app.Window().Get("JSON").Call("stringify", result).String()

					var resultMap map[string]interface{}

					// Unmarshal the raw string to []byte stream JSON to the interface map.
					if err := json.Unmarshal([]byte(rawJSON), &resultMap); err != nil {
						fmt.Printf("%s\n", err.Error())
					}

					// Update the UI's component.
					ctx.Dispatch(func(ctx app.Context) {
						m.Data = rawJSON
					})

					// Assert type string.
					msg, ok := resultMap["message"].(string)
					if !ok {
						return
					}

					// Logs "msg: lmao" to console.
					fmt.Printf("msg: %s\n", msg)
				})
			}
		})

		// Handle fetch errors
		promise.Call("catch", app.FuncOf(func(this app.Value, args []app.Value) interface{} {
			err := args[0].Get("message").String()

			// Log to console.
			fmt.Printf("Fetch error: %s\n", err)

			// Update the UI's component.
			ctx.Dispatch(func(ctx app.Context) {
				m.Data = err
			})

			return nil
		}))
	}()
}

func main() {
	app.Route("/", &MyApp{})
	app.RunWhenOnBrowser()

	r := chi.NewRouter()

	server := &http.Server{
		Addr:    ":8081",
		Handler: r,
	}

	// Build up a simple "backend API service".
	r.Get("/api/v1", func(w http.ResponseWriter, r *http.Request) {
		jData, err := json.Marshal(&struct {
			Message string `json:"message"`
		}{
			Message: "lmao",
		})
		if err != nil {
			w.Write([]byte(err.Error()))
			return
		}
		w.Write(jData)
	})

	r.Mount("/", &app.Handler{})

	fmt.Println(server.ListenAndServe())
}

// Export a Go function to JavaScript to interact with the DOM (for WASM purposes)
func init() {
	app.Window().Set("fetchData", app.FuncOf(func(this app.Value, args []app.Value) interface{} {
		go func() {
			fmt.Println("fetchData function called from JavaScript")
		}()
		return nil
	}))
}
